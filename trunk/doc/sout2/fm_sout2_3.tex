\section{Démarrage}

Après un non-démarrage du client \emph{Michon} pour la soutenance précèdente, il était donc tant pour nous de le commencer. Nous nous sommes donc décider à  nous lancer 
dans l'aventure de ce client avec Qt. Nous avons donc réussi à  nous retrouver, nous les 2 membres de cette partie du projet, Nicolas et Lionel. 
Nicolas a donc commencé par s'interresser à  la mise en place de notre projet sous QtDesigner tandis que moi, Lionel j'étais plutot orienté vers les sockets.


\section{Création de l'interface graphique et codage sous qtdesigner}
La création d'interfaces graphiques avec QtDesigner est très proche de celle sous Delphi, il suffit de disposer des objets et contrôles sur la fenêtre de la future 
application, puis de créer des fonctions/procédures qui se déclencheront lorsque l'utilisateur appuiera sur un bouton par exemple.
L'interface graphique actuelle, encore assez rudimentaire, permet de saisir, des commandes de l'utilisateur, et de traiter d'autres informations en 
parallèle grâce à un objet de type timer.


\section{Sockets}

Comme Sergueï et Benoit l'avaient découvert lors de la précèdente session, nous avons à notre tour découvert ces fameux sockets.
Le socket est donc ce qui va nous permettre de connecter notre cher client au serveur. Pour l'explication générale de ce qu'est le socket, il faut se ramener à  ce qu'avait 
expliqué Benoit et Sergueï lors de la soutenance précèdente.
Pour notre client, ça nous permettra de se connecter à un serveur IRC en rentrant son adresse IP ou son DNS ainsi que si ce n'est pas celle par défaut : 6667, le port utilisé.

Dans le cas de Qt, il y a la classe Qsocket qui existe et qui permet de se servir des sockets, de plus cela devrait pouvoir permettre une bonne portabilité du protocole 
si on le passe sous Windows car normalement cette classe existe autant sur le Qt de Linux que Windows.

Cependant l'utilisation de cette classe Qt a été un vrai calvaire pour la compréhension et la mise en place du socket sur le client.
Mais il est vrai qu'une fois mis en place, l'utilisation est simple et efficace.
La principale découverte impressionnante et ô combien efficace et utile pour la suite, c'est la connection de signals aux slots permettant par la suite de,
par exemple, recevoir le signal du serveur annonçant donc l'arrivée d'un message et ainsi pouvoir le lire directement, ça rend les choses tellement simple 
mais c'est tellement impressionnant quand on essaie de comprendre comment ça marche et que font tous ces connect(...).

\section{Traitement des messages}

Le client IRC \emph{Michon} se doit d'envoyer (de recevoir) des messages au (du) serveur. Une fois la lecture des messages tapés par l'utilisateur et la 
réception des messages du serveur par le client rendus possibles, il a fallu mettre en place la traduction par des actes par le client.

\subsection{Connection au serveur}

Pour se connecter à un serveur, l'utilisateur devra taper dans l'edit fait pour la réception des commandes de l'utilisateur : connect suivi de l'ip ou le DNS du serveur ainsi que le port utilisé s'il est différent du 6667.

exemple :
Pour connecter le socket sur un serveur lancé sur la machine H à l'epita sur le port 8792 l'utilisateur devra taper :
                 
                           connect H 8792

Si le client trouve le serveur et arrive à se connecter dessus, des messages le signifiant apparaitront.

\subsection{PASS}

Afin de se connecter en tant qu'utilisateur sur le serveur IRC, l'utilisateur doit par la suite entrer le pass du serveur IRC. Dans le cas où il n'y a pas de mot de passe, 
l'utilisateur aura quand même à écrire la commande pass suivi de rien car le serveur doit dans tous les cas recevoir cette commande.

exemple :
Il n'y a pas de pass pour le serveur :
                     
                          pass

\subsection{NICK}

L'utilisateur doit par la suite entrer son nickname (pseudo) utilisé sur le serveur.

exemple :
Le pseudo de l'utilisateur est momo :

                        nick momo

\subsection{USER}

L'utilisateur doit ensuite rentrer son vrai nom. pour cela il tapera la commande user suivi de son vrai nom.

exemple :
L'utilisateur s'appelle Seraphin Lampion :

                         user Seraphin Lampion

\subsection{PING/PONG}

Le serveur afin de vérifier que le client qu'il a en face de lui est toujours présent lui envoie un message PING auquel le client doit s'empresser de répondre PONG afin de signifier sa présence.
Ce message est répondu automatiquement par le client sans que l'utilisateur n'ait quoique ce soit à faire.