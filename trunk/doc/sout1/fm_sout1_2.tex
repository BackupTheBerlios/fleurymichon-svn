

\section{Implémentation du daemon}

Pour que l'application serveur puisse fonctionner convenablement, elle doit gagner son indépendance par rapport à la console depuis laquelle elle est appelée, devenant ainsi un daemon, c'est-à-dire une application résidant en mémoire et qui s'éxécute invisiblement en tâche de fond. Pour ce faire, nous avons utilisé principalement les fonctions \textit{fork()} et \textit{setsid()} afin d'isoler le processus du serveur Fleury de la console depuis laquelle il a été éxécuté. Ainsi, l'instance de Fleury nouvellement créée est détachée de la console, ce qui permet à l'utilisateur d'en reprendre le contrôle pendant que le serveur tourne en background. Donc le processus de l'application serveur se duplique et le processus originel quitte, ce qui donne un nouveau processus sans père, qui ne risque plus d'influencer le shell, qui en était le processus père auparavant.

\section{Sockets et protocole TCP}

Lorsqu'on évoque la notion de programmation réseau, on ne peut passer outre le concept de socket. Un socket est la combinaison d'un port et d'une adresse IP permettant 
de déterminer de manière unique une application éxécutée sur une machine. La communication via socket est souvent comparée à une communication humaines et on peut distinguer
deux modes :
\begin{itemize}
\item le mode \emph{connecté} (semblable à une communication téléphonique) utilisant le protocole TCP;
\item le mode \emph{non-connecté} (semblable à une communication par courrier) utilisant le protocole UDP.
\end{itemize}

Comme dans le cas de l'ouverture d'un fichier, la communication par socket utilise un descripteur pour désigner la connection sur laquelle on envoie ou reçoit les 
données. Ainsi la première opération à effectuer consiste à appeler une fonction créant un socket et retournant un descripteur (un entier) identifiant de manière unique 
la connection. Ainsi ce descripteur est passé en paramètres des fonctions permettant d'envoyer ou recevoir des informations à travers le socket.
Pour ce faire, nous avons fait appel aux fonctions et aux structure présentes dans la librairie standard \emph{sys/socket.h}.

\section{Concept de threads}

Pour plus de souplesse dans l'application serveur, nous avons fait appel au multi-threading. Un thread est un processus léger, ou encore une tâche qui a un rôle bien précis. L'avantage des threads est qu'on peut en éxécuter plusieurs qui fonctionneront en parallèle et qui auront accès aux mêmes données. Ainsi, une fois le serveur initialisé, l'application comporte un thread d'écoute, qui attend les connexions des clients et qui est chargé de générer un nouveau thread de traitement pour chaque client qui se connecte au serveur. Nous avons employé la bibliothèque de threads POSIX pour l'implémentation de ce sytème de traitement, ainsi le serveur peut fonctionner dans des environnements Linux et Cygwin mais Windows n'est pas exclu pour autant puisqu'un portage de cette bibliothèque pour ce système est disponible.

\section{Messages serveur}

Les serveurs et les clients s'envoient chacun des messages qui peuvent ou non générer une réponse. Chaque message IRC peut contenir jusqu'à trois parties : le 
préfixe (optionnel), la commande, et les paramètre de la commande (il peut y en avoir jusqu'à 15). Le préfixe, la commande, et tous les paramètres sont séparés 
par un (ou plusieurs) espace.

Pour cette première soutenance, nous avons commencé par implémenter les commandes de base, c'est-à-dire celles qui permettent l'établissement de la connection (PASS, NICK, USER, QUIT, \ldots)
ainsi que les commandes d'opérations sur les canaux (JOIN, MODE, \ldots).

\subsection{Établissement de la connexion}
Ce sont les commandes utilisées pour établir une connection avec un serveur IRC, aussi bien par un client que par un serveur, ainsi qu'une déconnexion correcte. 

\subsection{Opérations sur les canaux}
Ce groupe de messages s'intéresse à la manipulation de canaux, à leurs propriétés (mode des canaux), et à leur contenu (typiquement des clients).





