\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{fleury_ssh_ps_full.jpg}
\caption{Fleury sous Linux}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{fleury_cyg_ps.jpg}
\caption{Fleury sous Cygwin}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{fleury_cyg_session.jpg}
\caption{Exemple de communication client/serveur}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{fleury_cyg_log.jpg}
\caption{Log d'éxécution}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.8\linewidth]{fleury_mirc.jpg}
\caption{Connexion à un serveur Fleury depuis un client IRC populaire}
\end{figure}

\section{Implémentation du daemon}

Pour que l'application serveur puisse fonctionner convenablement, elle doit gagner son indépendance par rapport à la console depuis laquelle elle est appelée, devenant ainsi un daemon, c'est-à-dire une application résidant en mémoire et qui s'éxécute invisiblement en tâche de fond. Pour ce faire, nous avons utilisé principalement les fonctions \textit{fork()} et \textit{setsid()} afin d'isoler le processus du serveur Fleury de la console depuis laquelle il a été éxécuté. Ainsi, l'instance de Fleury nouvellement créée est détachée de la console, ce qui permet à l'utilisateur d'en reprendre le contrôle pendant que le serveur tourne en background. Donc le processus de l'application serveur se duplique et le processus originel quitte, ce qui donne un nouveau processus sans père, qui ne risque plus d'influencer le shell, qui en était le processus père auparavant. \\
Sous Linux, contrairement à \textbf{bash} et les autres commandes éxécutées par \textbf{bash}, Fleury est un processus indépendant de la console (\textbf{?} au lieu de \textbf{pts/0}). \textit{Voir Fig 2.1} \\
Sous Cygwin, c'est pareil. \textit{Voir Fig 2.2}

\section{Sockets et protocole TCP}

Lorsqu'on évoque la notion de programmation réseau, on ne peut passer outre le concept de socket. Un socket est la combinaison d'un port et d'une adresse IP permettant 
de déterminer de manière unique une application éxécutée sur une machine. La communication via socket est souvent comparée à une communication humaine et on peut distinguer
deux modes :
\begin{itemize}
\item le mode \emph{connecté} (semblable à une communication téléphonique) utilisant le protocole TCP;
\item le mode \emph{non-connecté} (semblable à une communication par courrier) utilisant le protocole UDP.
\end{itemize}

Comme dans le cas de l'ouverture d'un fichier, la communication par socket utilise un descripteur pour désigner la connection sur laquelle on envoie ou reçoit les 
données. Ainsi la première opération à effectuer consiste à appeler une fonction créant un socket et retournant un descripteur (un entier) identifiant de manière unique 
la connection. Ainsi ce descripteur est passé en paramètres des fonctions permettant d'envoyer ou recevoir des informations à travers le socket.
Pour ce faire, nous avons fait appel aux fonctions et aux structure présentes dans la librairie standard \emph{sys/socket.h}. De plus, l'échange d'informations par le biais de sockets peut se faire à l'aide de simples fonctions de formatages de chaînes de caractères haut niveau comme \textit{fscanf()}, \textit{fprintf()}, \textit{fgets()} \ldots

\section{Multi-threading}

Pour plus de souplesse dans l'application serveur, nous avons fait appel au multi-threading. Un thread est un processus léger, ou encore une tâche qui a un rôle bien précis. L'avantage des threads est qu'on peut en éxécuter plusieurs qui fonctionneront en parallèle et qui auront accès aux mêmes données. Ainsi, une fois le serveur initialisé, l'application comporte un thread d'écoute, qui attend les connexions des clients et qui est chargé de générer un nouveau thread de traitement pour chaque client qui se connecte au serveur. Nous avons employé la bibliothèque de threads POSIX pour l'implémentation de ce sytème de traitement, ainsi le serveur peut fonctionner dans des environnements Linux et Cygwin mais Windows n'est pas exclu pour autant puisqu'un portage de cette bibliothèque pour ce système est disponible. \\
Les identifiants des threads apparaissent entre crochets dans le log d'éxécution \textit{Voir Fig 2.4}

\section{Messages serveur}

Les serveurs et les clients s'envoient chacun des messages qui peuvent ou non générer une réponse. Chaque message IRC peut contenir jusqu'à trois parties : le 
préfixe (optionnel), la commande, et les paramètre de la commande (il peut y en avoir jusqu'à 15). Le préfixe, la commande, et tous les paramètres sont séparés 
par un (ou plusieurs) espace.

Pour cette première soutenance, nous avons commencé par implémenter les commandes de base, c'est-à-dire celles qui permettent l'établissement de la connection (PASS, NICK, USER, QUIT, \ldots)
ainsi que les commandes d'opérations sur les canaux (JOIN, MODE, \ldots).

\subsection{La commande PASS}

La commande PASS intervient au début de l'établissement d'une connexion entre un client et le serveur et sert à définir le mot de passe du client qui se connecte. Ce mot de passe sera utilisé plus tard, après l'implémentation de l'authentification dans le module de robots de gestion d'utilisateurs et de canaux.

\subsection{La commande NICK}

La commande NICK intervient également au début de la connexion et sert à définir le pseudonyme du client, qui sera utilisé pour dialoguer avec les autres clients. Elle peut également être utilisé par le client pendant une conversation pour changer de pseudonyme.

\subsection{La commande USER}

La commande USER est utilisée par le client pour définir son login et son nom réel. Elle n'est utilisée que durant l'établissement de la connexion.

\subsection{Les commandes PING/PONG}

La commande PING peut être utilisée indifféremment par les clients et serveurs pour vérifier l'état de la connexion avec n'importe quel autre client ou serveur cible, celui-ci devant répondre par un message PONG dans un délai dit de \og timeout \fg, avant d'être considéré comme déconnecté. Un message PING peut être envoyé à tous les clients par un serveur à intervalles réguliers pour fermer toutes les connexions fantômes, c'est-à-dire celles qui sont devenues inactives.

\subsection{La commande JOIN}

La commande JOIN est utilisée par un client pour rejoindre un canal dont il spécifiera le nom en paramètre. Le serveur envoie alors la commande JOIN avec le nom du nouveau venu à tous ceux qui sont présents sur le canal pour signaler son entrée. Le client est donc apte à dialoguer avec les autres sur ce canal. Heureusement, un client peut se connecter à plusieurs canaux en même temps.

\subsection{La commande PART}

La commande PART est utilisée par un client pour quitter un canal de discussion, cette commande sera alors broadcastée à tous les autres utilisateurs de ce canal.

\subsection{La commande QUIT}

La commande QUIT est utilisée par un client pour fermer la connexion avec le serveur. Le client peut passer en paramètre un éventuel message de départ. \\
\\
\textit{Exemple de communication: Voir Fig 2.3} \\
\\
\textit{Connexion à un serveur Fleury depuis mIRC: Voir fig 2.5}
