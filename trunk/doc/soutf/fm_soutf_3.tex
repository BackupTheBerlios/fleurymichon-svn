\section{Serveur \bsc{Fleury}}

\subsection{Impl\'{e}mentation du daemon}

Pour que l'application serveur puisse fonctionner convenablement, elle doit gagner son indépendance par rapport à la console depuis laquelle elle est appelée, devenant ainsi un daemon, c'est-à-dire une application résidant en mémoire et qui s'éxécute invisiblement en tâche de fond. Pour ce faire, nous avons utilisé principalement les fonctions \emph{fork()} et \emph{setsid()} afin d'isoler le processus du serveur Fleury de la console depuis laquelle il a été éxécuté. Ainsi, l'instance de Fleury nouvellement créée est détachée de la console, ce qui permet à l'utilisateur d'en reprendre le contrôle pendant que le serveur tourne en background. Donc le processus de l'application serveur se duplique et le processus originel quitte, ce qui donne un nouveau processus sans père, qui ne risque plus d'influencer le shell, qui en était le processus père auparavant. 
\\
Sous Linux, contrairement à \textbf{bash} et les autres commandes éxécutées par \textbf{bash}, Fleury est un processus indépendant de la console (\textbf{?} au lieu de \textbf{pts/0}).

\subsection{Sockets et protocole TCP}

Lorsqu'on évoque la notion de programmation réseau, on ne peut passer outre le concept de socket. Un socket est la combinaison d'un port et d'une adresse IP permettant de déterminer de manière unique une application éxécutée sur une machine. La communication via socket est souvent comparée à une communication humaine et on peut distinguer deux modes : 
\begin{itemize}
\item le mode \emph{connecté} (semblable à une communication téléphonique) utilisant le protocole TCP;
\item le mode \emph{non-connecté} (semblable à une communication par courrier) utilisant le protocole UDP.
\end{itemize}

Comme dans le cas de l'ouverture d'un fichier, la communication par socket utilise un descripteur pour désigner la connection sur laquelle on envoie ou reçoit les données. Ainsi la première opération à effectuer consiste à appeler une fonction créant un socket et retournant un descripteur (un entier) identifiant de manière unique la connection. Ainsi ce descripteur est passé en paramètres des fonctions permettant d'envoyer ou recevoir des informations à travers le socket. Pour ce faire, nous avons fait appel aux fonctions et aux structure présentes dans la librairie standard \emph{sys/socket.h}. De plus, l'échange d'informations par le biais de sockets peut se faire à l'aide de simples fonctions de formatages de chaînes de caractères haut niveau comme \textit{fscanf()}, \textit{fprintf()}, \textit{fgets()} \ldots

\subsection{Multi-threading}

Pour plus de souplesse dans l'application serveur, nous avons fait appel au multi-threading. Un thread est un processus léger, ou encore une tâche qui a un rôle bien précis. L'avantage des threads est qu'on peut en éxécuter plusieurs qui fonctionneront en parallèle et qui auront accès aux mêmes données. Ainsi, une fois le serveur initialisé, l'application comporte un thread d'écoute, qui attend les connexions des clients et qui est chargé de générer un nouveau thread de traitement pour chaque client qui se connecte au serveur. Nous avons employé la bibliothèque de threads POSIX pour l'implémentation de ce sytème de traitement, ainsi le serveur peut fonctionner dans des environnements Linux et Cygwin mais Windows n'est pas exclu pour autant puisqu'un portage de cette bibliothèque pour ce système est disponible. Les identifiants des threads apparaissent entre crochets dans le log d'éxécution.

\subsection{Commandes disponibles}

\subsection{Gestion des modes}

\subsubsection{Les modes des utilisateurs}

Les modes des utilisateurs permettent de les caractériser dans certains traitements de messages. Ainsi le mode +i active l'invisibilité pour certaines commandes de recherche d'utilisateurs. le mode +o global identifie les IRCops (les administrateurs du serveur) et ne peut être modifié par l'utilisateur, il est défini par le serveur à la suite d'une authentification réussie avec la commande OPER. Un utilisateur avec le mode +w (wallop) activé recevra les messages de notification de l'état du réseau.

\subsubsection{Les modes des canaux}

Les modes des canaux permettent principalement de définir des restrictions. Le mode +t permet de restreindre la modification du topic aux opérateurs du canal. Le mode +n désactive les messages externes, c'est-à-dire ceux émanant d'utilisateurs étrangers au canal. Le mode +m restreint la parole aux \textit{opérateurs} et \textit{voices}. Le mode +l définit le nombre maximal d'utilisateurs sur un canal. Le mode +k permet de définir un mot de passe pour le canal. Le mode +s rend le canal secret. Le mode +i le rend accessible sur invitation uniquement.

\subsubsection{Les modes des utilisateurs sur les canaux}

Le mode +b permet d'ajouter un masque de bannissement à la liste du canal pour interdire l'accès aux utilisateurs filtrés par ce masque. Les modes +o et +v permettent d'accorder des privilèges aux utilisateurs.

\subsection{Gestion des erreurs}

La RFC 1459 définit un certain nombres de messages d'erreurs permettant ainsi au serveur de gérer ces dernières de manière ordonné et efficace. Chaque réponse est présentée avec son numéro, son nom, et sa chaîne de réponse (en anglais). Par exemple, si un message est envoyé à un utilisateur inexistant, la réponse d'erreur sera : 401 ERR\_NOSUCHNICK "<pseudonyme> :No such nick/channel".

\subsection{Optimisations}

Certaines sections du code du serveur nécessitent des traitements de listes particulièrement délicats. Nous avions utilisé des définitions de fonctions imbriquées dans d'autres. Nous savons que ce n'est pas du langage C mais cela compilait magiquement avec GCC. Cependant, consciencieux comme nous sommes, nous avons pris le soin d'éliminer la vingtaine de fonctions imbriquées que nous utilisions en ajoutant simplement quelques paramètres à nos fonctions de traitement.

\section{Client \bsc{Michon}}


